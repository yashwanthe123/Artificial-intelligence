from copy import deepcopy

def read_state(prompt):
    while True:
        print(prompt)
        numbers = input().strip().split()
        if len(numbers) != 9 or not all(n.isdigit() for n in numbers):
            print("Error: Enter exactly 9 numbers separated by spaces (0 for blank). Try again.")
            continue
        numbers = list(map(int, numbers))
       
        if set(numbers) != set(range(9)):
            print("Error: Numbers must be from 0 to 8 with no duplicates. Try again.")
            continue
        return [numbers[i*3:(i+1)*3] for i in range(3)]

def find_position(state, value):
    for i in range(3):
        for j in range(3):
            if state[i][j] == value:
                return i, j
    return None

def manhattan_distance(state, goal):
    distance = 0
    for i in range(3):
        for j in range(3):
            val = state[i][j]
            if val != 0:
                goal_i, goal_j = find_position(goal, val)
                distance += abs(i - goal_i) + abs(j - goal_j)
    return distance

def find_blank(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def get_neighbors(state):
    neighbors = []
    x, y = find_blank(state)
    moves = [(-1, 0, "up"), (1, 0, "down"), (0, -1, "left"), (0, 1, "right")]
    for dx, dy, move in moves:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = deepcopy(state)
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append((new_state, move))
    return neighbors

def print_state(state):
    for row in state:
        print(row)
    print()

def hill_climbing(initial_state, goal_state, max_iterations=1000):
    current = initial_state
    current_h = manhattan_distance(current, goal_state)
    steps = 0
    path = []  
   
    print(f"Step {steps}: (Manhattan Distance: {current_h})")
    print_state(current)
   
    while steps < max_iterations:
        neighbors = get_neighbors(current)
        neighbor_h = [(manhattan_distance(n[0], goal_state), n[0], n[1]) for n in neighbors]
       
        neighbor_h.sort(key=lambda x: x[0])
        best_h, best_state, best_move = neighbor_h[0]
       
        if best_h >= current_h:
            return current, current_h, steps, path
       
        current, current_h = best_state, best_h
        path.append(best_move)  
        steps += 1
       
        print(f"Step {steps}: Move: {best_move} (Manhattan Distance: {current_h})")
        print_state(current)
   
    return current, current_h, steps, path

if __name__ == "__main__":
    initial_state = read_state("Enter the initial state (9 numbers 0-8 with 0 as blank, separated by spaces):")
    goal_state = read_state("Enter the goal state (9 numbers 0-8 with 0 as blank, separated by spaces):")
   
    print("\nInitial State:")
    print_state(initial_state)
   
    print("Goal State:")
    print_state(goal_state)
   
    final_state, h, steps, path = hill_climbing(initial_state, goal_state)
   
    print(f"Final State after Hill Climbing (after {steps} steps):")
    print_state(final_state)
    print(f"Manhattan Distance: {h}")
   
    if h == 0:
        print("Reached goal state!")
    else:
        print("Stopped at local minimum (not solved).")
   
    if path:
        print("Final Path of moves:")
        print("Start -> " + " -> ".join(path) + " -> Goal")
    else:
        print("No moves made.")
