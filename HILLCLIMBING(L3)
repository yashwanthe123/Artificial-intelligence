def read_state(prompt):
    print(prompt)
    numbers = input().strip().split()
    if len(numbers) != 9 or not all(n.isdigit() for n in numbers):
        print("Enter exactly 9 numbers separated by spaces.")
        return read_state(prompt)
    return [list(map(int, numbers[i*3:(i+1)*3])) for i in range(3)]

def misplaced_tiles(state, goal):
    return sum(
        1 for i in range(3) for j in range(3)
        if state[i][j] != 0 and state[i][j] != goal[i][j]
    )

def find_zero(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def get_neighbors(state):
    neighbors = []
    x, y = find_zero(state)
    moves = [(-1,0), (1,0), (0,-1), (0,1)]
    for dx, dy in moves:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = [row[:] for row in state]
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append(new_state)
    return neighbors

def state_equal(s1, s2):
    return all(s1[i][j] == s2[i][j] for i in range(3) for j in range(3))

def solve(initial, goal, max_steps=30):
    current = initial
    steps = 0
    visited = []

    print("Starting state:")
    for row in current:
        print(row)

    while not state_equal(current, goal) and steps < max_steps:
        visited.append(current)
        neighbors = get_neighbors(current)
        best = None
        lowest_h = float('inf')
        for neighbor in neighbors:
            if any(state_equal(neighbor, v) for v in visited):
                continue
            h = misplaced_tiles(neighbor, goal)
            if h < lowest_h:
                lowest_h = h
                best = neighbor
        if best is None:
            print("No more moves or stuck. Aborting.")
            return
        current = best
        steps += 1
        print(f"\nStep {steps}, Misplaced tiles: {lowest_h}")
        for row in current:
            print(row)
            
    if state_equal(current, goal):
        print("\nSolved in", steps, "steps!")
    else:
        print("\nMax steps reached or stuck, not solved.")

initial_state = read_state("Enter the initial state (use 0 for blank):")
goal_state = read_state("Enter the goal state:")

solve(initial_state, goal_state)
